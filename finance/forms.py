# finance/forms.py
from django import forms
from django.core.exceptions import ValidationError
from .models import Transaction, Category
import datetime

class TransactionForm(forms.ModelForm):
    """
    Форма для добавления новой финансовой операции.
    """
    # Мы можем переопределить поля из модели, если нужно добавить виджеты или логику.
    # Например, для даты можно использовать виджет выбора даты.
    date = forms.DateField(
        widget=forms.DateInput(attrs={'type': 'date'}), # Используем HTML5 input для выбора даты
        label="Дата операции", # Изменим отображаемый текст (label) для формы
        help_text="Укажите дату операции." # Добавим подсказку
    )

    class Meta:
        model = Transaction
        # Укажем, какие поля включать в форму. Все обязательные + description.
        fields = ['amount', 'date', 'type', 'category', 'description']
        # labels и help_texts можно определить здесь, но мы сделали label для date выше.
        labels = {
            'amount': 'Сумма',
            'type': 'Тип операции',
            'category': 'Категория',
            'description': 'Описание (необязательно)',
        }
        help_texts = {
            'amount': 'Введите положительное число.',
            'description': 'Краткое описание операции (по желанию).',
        }

    def __init__(self, *args, **kwargs):
        # Добавим отладку при инициализации формы
        print("DEBUG: TransactionForm.__init__ called")
        super().__init__(*args, **kwargs)
        # Убедимся, что queryset для category загружается корректно
        # Это стандартный способ, Django сам подставит все категории
        # Если вы хотите ограничить категории, делайте это тут:
        # self.fields['category'].queryset = Category.objects.filter(...) # если нужно

    def clean_date(self):
        """
        Валидация поля 'date'.
        Проверяет, что дата не в будущем, или запрашивает подтверждение.
        Django-формы не могут напрямую запрашивать подтверждение от пользователя
        в том же духе, что "да/нет" в консоли из ТЗ.
        В Django подтверждение обычно реализуется через:
        1. Вторую форму/шаг (например, предварительный просмотр).
        2. JavaScript на стороне клиента.
        3. Отдельную логику в представлении (View).

        Для MVP, самый распространенный и простой подход - это либо
        просто запретить дату в будущем (валидация), либо позволить ввод,
        но логировать или как-то помечать такие случаи.

        В ТЗ указано "с запросом подтверждения". Это сложнее реализовать
        стандартными средствами форм Django. Часто делают так:
        - Разрешают ввод в будущем в форме.
        - В представлении (View), перед сохранением, проверяют дату.
        - Если дата в будущем, показывают ту же форму с особым сообщением
          или используют второй шаг подтверждения.

        Пока что, в рамках *формы*, мы выполним проверку и вызовем ValidationError,
        если дата в будущем. Это соответствует строгой валидации.
        Если позже решим реализовать подтверждение, логику перенесем в View.
        """
        date = self.cleaned_data.get('date')
        if date and date > datetime.date.today():
            # Вариант 1: Строгая валидация - запретить дату в будущем.
            # raise ValidationError("Дата операции не может быть в будущем.")

            # Вариант 2: Позволить, но отметить (например, для последующей обработки в View).
            # В этом случае просто не делаем ничего, поле пройдет валидацию как есть.
            # Однако, чтобы придерживаться духа ТЗ о "подтверждении", можно
            # добавить пользовательское сообщение в форму, но не вызывать ValidationError.
            # Это делается через self.add_error или передачу в шаблон отдельно.
            # Наиболее соответствующий вариант для формы - всё же.ValidationError,
            # но с сообщением, которое можно интерпретировать как "подтверждение валидации".
            # Или, как часто делают, разрешают, но в View обрабатывают отдельно.
            # Давайте пока оставим разрешение и перенесем "подтверждение" в View.
            # Для формы: просто валидация проходит, но мы можем установить флаг или
            # передать сообщение в View. Пока что - просто пропускаем.
            # raise ValidationError("Дата указана в будущем. Вы уверены? (Это будет обработано далее)")
            # Нет, лучше не вызывать ValidationError здесь, если мы хотим "подтверждения".
            # Вместо этого, просто возвращаем дату как есть, а проверку и логику подтверждения
            # реализуем в представлении (View).
            pass # Просто пропускаем проверку в форме для MVP, если подтверждение нужно в View
        return date

    def clean_amount(self):
        """
        Валидация поля 'amount'.
        Проверяет, что сумма > 0.
        (Мы также добавили MinValueValidator в модель, но форма - это другой уровень проверки).
        Проверка в модели более надежна, но форма тоже может проверять.
        """
        amount = self.cleaned_data.get('amount')
        if amount and amount <= 0:
            raise ValidationError("Сумма должна быть больше 0.")
        return amount

    # Если нужно, можно добавить кастомную валидацию для всей формы
    # def clean(self):
    #     cleaned_data = super().clean()
    #     # Пример: проверка комбинации полей
    #     # amount = cleaned_data.get("amount")
    #     # category = cleaned_data.get("category")
    #     # if ...:
    #     #     raise ValidationError("Некорректная комбинация данных.")
    #     return cleaned_data